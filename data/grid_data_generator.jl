using Distributions
using StaticArrays
using HitchhikingDrones
using Gadfly
using JSON
using StatsBase
#=
This script generates episodes for cars with no misses and bounded delays (of unknown bounds)
It assumes that the environment is [-1,-1] to [1,1] and the start position of the drone is always
# [0,0]. The goal is generated randomly and is always at least 1 unit away.
The car routes are generated by randomly sampling two points at least 1 unit away from each other
and then the route is either the straight line between them or an L-shaped route.
The episode is always 30 minutes long and each epoch is of 5 seconds (but these parameters can
be changed). Thus each episode has 360 epochs
The range of cars in the episode is specified as a command line argument. Roughly 1/2 of the cars
are introduced in the first 10 minutes, 1/6th of the cars in the next 10 minutes, and 1/6th of the cars
in the final 10 minutes.
=#
const AVG_ROUTE_DURATION = 500.0 # seconds
const AVG_ROUTE_WAYPOINTS = 10
const EPISODE_DURATION = 1800.0
const EPOCH_DURATION = 5.0
const START_GOAL_MINDIST = 0.75
const ROUTE_MIN_LENGTH = 0.2
const ROUTE_MAX_LENGTH = 1.0
const STRAIGHT_ROUTE_PROB = 0.5 # Probability that car route will be a straight line, else L shaped
const MODIFY_WAYPT_PROB = 0.75
const MAX_CAR_SPEED = 0.007



function inside_grid(p::SVector{2,Float64})
    if p[1] <= -1.0 || p[1] >= 1.0 || p[2] <= -1.0 || p[2] >= 1.0
        return false
    end
    return true
end

function point_dist(p1::SVector{2,Float64}, p2::SVector{2,Float64})
    return sqrt((p1[1] - p2[1])^2 + (p1[2] - p2[2])^2)
end

function rand_unif_grid_pt(rng::RNG=Base.GLOBAL_RNG) where {RNG <: AbstractRNG}
    return SVector{2, Float64}(rand(rng,Uniform(-1.0,1.0)), rand(rng,Uniform(-1.0,1.0)))
end

function interpolate_points_on_line(first_pos::SVector{2,Float64}, last_pos::SVector{2,Float64}, num_pts::Int)

    line_pts = Vector{SVector{2,Float64}}(num_pts)
    x_pts = linspace(first_pos[1], last_pos[1], num_pts)
    y_pts = linspace(first_pos[2], last_pos[2], num_pts)

    for i = 1:num_pts
        line_pts[i] = SVector{2,Float64}(x_pts[i], y_pts[i])
    end

    return line_pts
end

# This is always for the about-to-happen epoch so time was advanced prior to this
function perturb_car_route_times!(curr_time::Float64, car_ep_dict::Dict, perturb_prob::Float64=MODIFY_WAYPT_PROB, rng::RNG=Base.GLOBAL_RNG) where {RNG <: AbstractRNG}

    # Modify each way point expected time with the probability
    route = car_ep_dict["route"]

    latest_time = curr_time
    sorted_route_keys = sort(collect(keys(route)))

    for (idx,rk) in enumerate(sorted_route_keys[1:end-1])
        pt_time = route[rk]
        next_pt_time = route[sorted_route_keys[idx+1]]

        @assert pt_time[2] < next_pt_time[2]

        if rand(rng) < perturb_prob && (pt_time[2] - latest_time > 2.0*EPOCH_DURATION) && (next_pt_time[2] - pt_time[2] > 2.0*EPOCH_DURATION)
            pt_time[2] = pt_time[2] + rand(rng,Uniform(-EPOCH_DURATION, EPOCH_DURATION))
        end
        latest_time = max(pt_time[2], latest_time)
    end

end

# simulates the new position of the car
# based on current position and average speed
# I.E. the delays incorporate the speedup etc
# If car crosses the next waypoint, remove the waypoint from the dict
function advance_cars_with_epoch!(car_ep_dict::Dict, curr_time::Float64)

    if car_ep_dict["route"] == nothing
        return
    end

    latest_passed_pos = copy(car_ep_dict["pos"])
    new_time = curr_time + EPOCH_DURATION
    latest_passed_time = curr_time

    sorted_route = sort(collect(car_ep_dict["route"]), by=x-> x[1])

    for (id,timept) in sorted_route
        if new_time > timept[2]
            latest_passed_pos = copy(timept[1])
            latest_passed_time = timept[2]
            delete!(car_ep_dict["route"],id)
        else
            break
        end
    end

    if length(car_ep_dict["route"]) == 0
        car_ep_dict["route"] = nothing
    else
        # Generate a new point between latest passed pos and
        # next route on path
        sorted_route = sort(collect(car_ep_dict["route"]), by=x->x[1])
        next_car_pt = sorted_route[1][2][1] # TODO : Is this correct?
        next_car_pt_time = sorted_route[1][2][2]
        
        # Generate new point in between latest and next
        time_frac = (new_time - latest_passed_time)/(next_car_pt_time - latest_passed_time)

        est_pos = SVector{2,Float64}(latest_passed_pos[1] + time_frac*(next_car_pt[1] - latest_passed_pos[1]),
                                     latest_passed_pos[2] + time_frac*(next_car_pt[2] - latest_passed_pos[2]))
        car_ep_dict["pos"] = est_pos
    end
end

# Generates 'pos' and 'route' for the first epoch that a car is active
function generate_initial_car_route(start_time::Float64, rng::RNG=Base.GLOBAL_RNG) where {RNG <: AbstractRNG}

    route_duration = rand(rng,Uniform(0.2*AVG_ROUTE_DURATION, 1.8*AVG_ROUTE_DURATION))

    car_start_pos = rand_unif_grid_pt(rng)

    car_goal_pos = rand_unif_grid_pt(rng)
    route_length = point_dist(car_start_pos, car_goal_pos)
    while route_length < ROUTE_MIN_LENGTH || route_length > min(ROUTE_MAX_LENGTH,MAX_CAR_SPEED*route_duration) 
        car_goal_pos = rand_unif_grid_pt(rng)
        route_length = point_dist(car_start_pos, car_goal_pos)
    end

    
    route_num_waypts = convert(Int,round(rand(rng,Uniform(0.5*AVG_ROUTE_WAYPOINTS, 1.5*AVG_ROUTE_WAYPOINTS))))
    while route_num_waypts > (route_duration / (2.2*EPOCH_DURATION))
        route_num_waypts = convert(Int,round(rand(rng,Uniform(0.5*AVG_ROUTE_WAYPOINTS, 1.5*AVG_ROUTE_WAYPOINTS))))
    end


    route_dict = Dict("pos"=>car_start_pos,"route"=>Dict())

    if rand(rng) < STRAIGHT_ROUTE_PROB
        # Straight line route
        route_waypts = interpolate_points_on_line(car_start_pos, car_goal_pos, route_num_waypts+1)

        for i = 1:route_num_waypts
            # Assume uniformly spread for now
            route_dict["route"][i] = [route_waypts[i+1],start_time + i*(route_duration/route_num_waypts)]
        end
    else
        # Generate an inflection point randomly between 5/12ths and 7/12ths of the route
        inflec_frac = rand(rng,Uniform(1/3,2/3))

        # Sample a point in a circle around the 
        inflec_point = SVector{2,Float64}(car_start_pos[1] + inflec_frac*(car_goal_pos[1]-car_start_pos[1]),
                                          car_start_pos[2] + inflec_frac*(car_goal_pos[2]-car_start_pos[2]))
        # 
        angle1 = atan2(car_goal_pos[2]-car_start_pos[2], car_goal_pos[1]-car_start_pos[1]) - pi/2
        angle2 = atan2(car_goal_pos[2]-car_start_pos[2], car_goal_pos[1]-car_start_pos[1]) + pi/2

        interm_point = SVector{2,Float64}(inflec_point[1] + 0.5*route_length*cos(angle1), inflec_point[2] + 0.5*route_length*sin(angle1))
        if !inside_grid(interm_point)
            interm_point = SVector{2,Float64}(inflec_point[1] + 0.5*route_length*cos(angle2), inflec_point[2] + 0.5*route_length*sin(angle2))
        end

        if !inside_grid(interm_point)
            warn("Intermediate inflection logic incorrect! Both interms invalid.")

            route_waypts = interpolate_points_on_line(car_start_pos, car_goal_pos, route_num_waypts+1)

            for i = 1:route_num_waypts
                # Assume uniformly spread for now
                route_dict["route"][i] = [route_waypts[i+1],start_time + i*(route_duration/route_num_waypts)]
            end
        else
            avg_speed = route_length/route_num_waypts
            route_waypts = interpolate_points_on_line(car_start_pos, interm_point, convert(Int,round(point_dist(car_start_pos,interm_point)/avg_speed)))

            # rmeove last way point
            pop!(route_waypts)
            route_waypts = vcat(route_waypts, 
                interpolate_points_on_line(interm_point, car_goal_pos, convert(Int,round(point_dist(interm_point, car_goal_pos)/avg_speed))))

            for i = 1:length(route_waypts)-1
                route_dict["route"][i] = [route_waypts[i+1],start_time + i*(route_duration/route_num_waypts)]
            end
        end
    end

    perturb_car_route_times!(start_time, route_dict, 1.0)

    return route_dict
end    


function generate_episode_dict_unitgrid(min_cars::Int, max_cars::Int,rng::RNG=Base.GLOBAL_RNG) where {RNG <: AbstractRNG}

    num_epochs = convert(Int,round((EPISODE_DURATION/EPOCH_DURATION)))
    num_total_cars = rand(rng, min_cars:max_cars)
    num_added_cars = 0

    println("Cars : ",num_total_cars)


    # Start is always 0.0
    start_pos = SVector{2,Float64}(0.0,0.0)

    # Generate goal as a random 2D point at least 1 unit away from start
    goal_pos = rand_unif_grid_pt(rng)
    while point_dist(start_pos, goal_pos) < START_GOAL_MINDIST
        goal_pos = rand_unif_grid_pt(rng)
    end

    # Initialize episode_dict
    episode_dict = Dict("num_epochs"=>num_epochs, "start_pos"=>start_pos, "goal_pos"=>goal_pos, "epochs"=>Dict())

    epoch_time = 0.0

    # Start off with 0.5 of the cars and then just add randomly
    cars_to_add = convert(Int, round(0.5*num_total_cars))

    epoch0_dict = Dict("time"=>0.0, "car-info"=>Dict())

    for i=1:cars_to_add
        num_added_cars += 1
        epoch0_dict["car-info"][string("car-",num_added_cars)] = generate_initial_car_route(epoch_time)
    end

    episode_dict["epochs"][0] = epoch0_dict

    epochs_to_add = sort(sample(Base.GLOBAL_RNG,2:num_epochs,10,replace=false))

    for epoch_idx = 1:num_epochs

        curr_epoch_dict = deepcopy(episode_dict["epochs"][epoch_idx-1])
        
        # First advance existing cars with new epoch
        # TODO - Are we handling times correctly here
        for car_id in collect(keys(curr_epoch_dict["car-info"]))
            advance_cars_with_epoch!(curr_epoch_dict["car-info"][car_id],epoch_time)
        end

        # Advance time for curr_epoch_dict
        epoch_time += EPOCH_DURATION
        curr_epoch_dict["time"] = epoch_time

        # Perturb the times over the rest of the route
        for (car_id,car_ep_dict) in curr_epoch_dict["car-info"]
            if car_ep_dict["route"] != nothing
                perturb_car_route_times!(epoch_time, car_ep_dict)
            end
        end

        cars_to_add = 0

        if epoch_idx in epochs_to_add
            cars_to_add = convert(Int64,round(num_total_cars/20))
            # println(cars_to_add," cars added in epoch ",epoch_idx)
        end


        # Now add cars
        for i = 1:cars_to_add
            num_added_cars += 1
            curr_epoch_dict["car-info"][string("car-",num_added_cars)] = generate_initial_car_route(epoch_time)
        end
    
        episode_dict["epochs"][epoch_idx] = curr_epoch_dict

    end

    return episode_dict,start_pos,goal_pos
end



# Script level code
#Arguments are <min-cars> <max-cars> <file-name> <num-files>
min_cars = parse(Int,ARGS[1])
max_cars = parse(Int, ARGS[2])
filename_pref = ARGS[3]
num_files = parse(Int,ARGS[4])

for idx = 1:num_files
    println("File ",idx)
    filename = string(filename_pref,"-",idx,".json")
    ep_dict,start_pos,goal_pos = generate_episode_dict_unitgrid(min_cars, max_cars)
    epochs_dict = ep_dict["epochs"]

    open(filename,"w") do f
        JSON.print(f,ep_dict,2)
    end
end

# color_map = Dict()
# p = plot_drone_and_active_cars_epoch!(epochs_dict[1], Point(start_pos[1],start_pos[2]), Point(goal_pos[1],goal_pos[2]), color_map)
# draw(PNG(fig_fn,10inch,10inch), p)