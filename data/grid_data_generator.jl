# stdlib
using Random
using Statistics
using LinearAlgebra
using Distributions

# Extra pkgs
using StaticArrays
using JSON
using TOML

using HitchhikingDrones
using Gadfly

#=
This script generates episodes for cars with no rerouting and bounded transit times
It assumes that the environment is [-1,-1] to [1,1] and the start position of the drone is always
# [0,0]. The goal is generated randomly and is always at least 1 unit away.
The car routes are generated by randomly sampling two points at least 1 unit away from each other
and then the route is either the straight line between them or an L-shaped route.
The episode is always 30 minutes long and each epoch is of 5 seconds (but these parameters can
be changed). Thus each episode has 360 epochs
The range of cars in the episode is specified as a command line argument. Roughly 1/2 of the cars
are introduced in the first 10 minutes, 1/6th of the cars in the next 10 minutes, and 1/6th of the cars
in the final 10 minutes.
=#
struct DataScaleParameters
    START_GOAL_MINDIST::Float64
    ROUTE_MIN_LENGTH::Float64
    ROUTE_MAX_LENGTH::Float64
    MAX_CAR_SPEED::Float64
end

struct DataTimeParameters
    AVG_ROUTE_DURATION::Float64 # seconds
    EPISODE_DURATION::Float64
    EPOCH_DURATION::Float64
end

struct DataRouteParameters
    AVG_ROUTE_WAYPOINTS::Int
    STRAIGHT_ROUTE_PROB::Float64
    MODIFY_WAYPT_PROB::Float64
end

struct DataParameters
    scale_params::DataScaleParameters
    time_params::DataTimeParameters
    route_params::DataRouteParameters
end


function parse_data_params(all_in_one_file::AbstractString)

    params_key = TOML.parsefile(all_in_one_file)

    scale_params = DataScaleParameters(params_key["START_GOAL_MINDIST"],
                                       params_key["ROUTE_MIN_LENGTH"],
                                       params_key["ROUTE_MAX_LENGTH"],
                                       params_key["MAX_CAR_SPEED"])

    time_params = DataTimeParameters(params_key["AVG_ROUTE_DURATION"],
                                     params_key["EPISODE_DURATION"],
                                     params_key["EPOCH_DURATION"])

    route_params = DataRouteParameters(params_key["AVG_ROUTE_WAYPOINTS"],
                                       params_key["STRAIGHT_ROUTE_PROB"],
                                       params_key["MODIFY_WAYPT_PROB"])

    return DataParameters(scale_params, time_params, route_params)
end

"""
    inside_grid(p::SVector{2,Float64})

Check if the point p is inside the grid of [-1,-1] to [1,1] (excluding boundaries)
"""
function inside_grid(p::SVector{2,Float64})
    if p[1] <= -1.0 || p[1] >= 1.0 || p[2] <= -1.0 || p[2] >= 1.0
        return false
    end
    return true
end

"""
    point_dist(p1::SVector{2,Float64}, p2::SVector{2,Float64}, l::Float64=2.0)

Compute L_p norm between two 2D points
"""
function point_dist(p1::SVector{2,Float64}, p2::SVector{2,Float64}, l::Float64=2.0)
    return norm(p1-p2,l)
end

"""
    rand_unif_grid_pt(rng::RNG=Base.GLOBAL_RNG) where {RNG <: AbstractRNG}

Generate a random 2D point inside the grid of [-1,-1] to [1,1]
"""
function rand_unif_grid_pt(rng::RNG=Random.GLOBAL_RNG) where {RNG <: AbstractRNG}
    return SVector{2, Float64}(rand(rng,Uniform(-1.0,1.0)), rand(rng,Uniform(-1.0,1.0)))
end

"""
    interpolate_points_on_line(first_pos::SVector{2,Float64}, last_pos::SVector{2,Float64}, num_pts::Int)

Generate a vector of 2D points linearly interpolated from first_pos to last_pos, both inclusive
"""
function interpolate_points_on_line(first_pos::SVector{2,Float64}, last_pos::SVector{2,Float64}, num_pts::Int)

    line_pts = Vector{SVector{2,Float64}}(undef,num_pts)
    x_pts = collect(range(first_pos[1], stop=last_pos[1],length=num_pts))
    y_pts = collect(range(first_pos[2], stop=last_pos[2],length=num_pts))

    for i = 1:num_pts
        line_pts[i] = SVector{2,Float64}(x_pts[i], y_pts[i])
    end

    return line_pts
end

# This is always for the about-to-happen epoch so time was advanced prior to this
"""
    perturb_car_route_times!(curr_time::Float64, car_ep_dict::Dict, params::DataParameters, rng::RNG=Random.GLOBAL_RNG) where {RNG <: AbstractRNG}

Perturb the remaining waypoints of a car route with the waypoint perturbation parameter.
"""
function perturb_car_route_times!(curr_time::Float64, car_ep_dict::Dict, params::DataParameters, rng::RNG=Random.GLOBAL_RNG) where {RNG <: AbstractRNG}

    # Modify each way point expected time with the probability
    route = car_ep_dict["route"]

    latest_time = curr_time
    sorted_route_keys = sort(collect(keys(route)))

    for (idx,rk) in enumerate(sorted_route_keys[1:end-1])
        pt_time = route[rk]
        next_pt_time = route[sorted_route_keys[idx+1]]

        @assert pt_time[2] < next_pt_time[2] "Waypoint times are out of order"

        # Ensure that the perturbation will not violate current ordering
        if rand(rng) < params.route_params.MODIFY_WAYPT_PROB && 
            (pt_time[2] - latest_time > 2.0*params.time_params.EPOCH_DURATION) && 
            (next_pt_time[2] - pt_time[2] > 2.0*params.time_params.EPOCH_DURATION)
            pt_time[2] = pt_time[2] + rand(rng,Uniform(-params.time_params.EPOCH_DURATION, params.time_params.EPOCH_DURATION))
        end
        latest_time = max(pt_time[2], latest_time)
    end
end

# simulates the new position of the car
# based on current position and average speed
# I.E. the delays incorporate the speedup etc
# If car crosses the next waypoint, remove the waypoint from the dict
"""
    advance_cars_with_epoch!(car_ep_dict::Dict, curr_time::Float64, params::DataParameters)

Propagate a car forward to its new position at the next epoch, based on current position and average speed.
If car crosses the next waypoint, remove the waypoint from the dict.
"""
function advance_cars_with_epoch!(car_ep_dict::Dict, curr_time::Float64, params::DataParameters)

    if car_ep_dict["route"] == nothing
        return
    end

    # Find the latest waypoint crossed by the car.
    latest_passed_pos = copy(car_ep_dict["pos"])
    new_time = curr_time + params.time_params.EPOCH_DURATION
    latest_passed_time = curr_time

    sorted_route = sort(collect(car_ep_dict["route"]), by=x-> x[1])

    # Remove waypoint from route if crossed
    for (id,timept) in sorted_route
        if new_time > timept[2]
            latest_passed_pos = copy(timept[1])
            latest_passed_time = timept[2]
            delete!(car_ep_dict["route"],id)
        else
            break
        end
    end

    if length(car_ep_dict["route"]) == 0
        # Route has finished, last waypoint crossed.
        car_ep_dict["route"] = nothing
    else
        # Generate a new point between latest passed pos and next route on path
        sorted_route = sort(collect(car_ep_dict["route"]), by=x->x[1])
        next_car_pt = sorted_route[1][2][1]
        next_car_pt_time = sorted_route[1][2][2]
        
        # Generate new point in between latest and next
        time_frac = (new_time - latest_passed_time)/(next_car_pt_time - latest_passed_time)

        est_pos = SVector{2,Float64}(latest_passed_pos[1] + time_frac*(next_car_pt[1] - latest_passed_pos[1]),
                                     latest_passed_pos[2] + time_frac*(next_car_pt[2] - latest_passed_pos[2]))
        car_ep_dict["pos"] = est_pos
    end
end


"""
    generate_initial_car_route(start_time::Float64, params::DataParameters, rng::RNG=Random.GLOBAL_RNG) where {RNG <: AbstractRNG}

Generates 'pos' and 'route' for the first epoch that a car is active.
"""
function generate_initial_car_route(start_time::Float64, params::DataParameters, rng::RNG=Random.GLOBAL_RNG) where {RNG <: AbstractRNG}

    route_duration = rand(rng,Uniform(0.2*params.time_params.AVG_ROUTE_DURATION, 1.8*params.time_params.AVG_ROUTE_DURATION))

    # Generate start randomly
    car_start_pos = rand_unif_grid_pt(rng)
    
    # Generate goal by rejection sampling until route has sufficient distance (but not too high)
    car_goal_pos = rand_unif_grid_pt(rng)
    route_length = point_dist(car_start_pos, car_goal_pos)
    while route_length < params.scale_params.ROUTE_MIN_LENGTH || 
        route_length > min(params.scale_params.ROUTE_MAX_LENGTH, params.scale_params.MAX_CAR_SPEED*route_duration) 
        car_goal_pos = rand_unif_grid_pt(rng)
        route_length = point_dist(car_start_pos, car_goal_pos)
    end

    # Generate a reasonable number of route waypoints, such that no two fall in the same epoch    
    route_num_waypts = convert(Int,round(rand(rng,Uniform(0.5*params.route_params.AVG_ROUTE_WAYPOINTS, 1.5*params.route_params.AVG_ROUTE_WAYPOINTS))))
    while route_num_waypts > (route_duration / (2.2*params.time_params.EPOCH_DURATION))
        route_num_waypts = convert(Int,round(rand(rng,Uniform(0.5*params.route_params.AVG_ROUTE_WAYPOINTS, 1.5*params.route_params.AVG_ROUTE_WAYPOINTS))))
    end


    route_dict = Dict("pos"=>car_start_pos,"route"=>Dict())

    if rand(rng) < params.route_params.STRAIGHT_ROUTE_PROB
        # Straight line route
        route_waypts = interpolate_points_on_line(car_start_pos, car_goal_pos, route_num_waypts+1)

        for i = 1:route_num_waypts
            # Assume uniformly spread for now
            route_dict["route"][i] = [route_waypts[i+1],start_time + i*(route_duration/route_num_waypts)]
        end
    else
        # Generate an inflection point randomly between 1/3 and 2/3 of the route
        inflec_frac = rand(rng,Uniform(1/3,2/3))

        # Sample a point in a circle around the elbow point
        inflec_point = SVector{2,Float64}(car_start_pos[1] + inflec_frac*(car_goal_pos[1]-car_start_pos[1]),
                                          car_start_pos[2] + inflec_frac*(car_goal_pos[2]-car_start_pos[2]))
        
        angle1 = atan(car_goal_pos[2]-car_start_pos[2], car_goal_pos[1]-car_start_pos[1]) - pi/2
        angle2 = atan(car_goal_pos[2]-car_start_pos[2], car_goal_pos[1]-car_start_pos[1]) + pi/2

        # Generate the intermediate point which is the elbow of the L. Use the elbow on the side side that is inside grid.
        interm_point = SVector{2,Float64}(inflec_point[1] + 0.5*route_length*cos(angle1), inflec_point[2] + 0.5*route_length*sin(angle1))
        if !inside_grid(interm_point)
            interm_point = SVector{2,Float64}(inflec_point[1] + 0.5*route_length*cos(angle2), inflec_point[2] + 0.5*route_length*sin(angle2))
        end

        # Ensure that at least 1 elbow is inside grid (it should be)
        if !inside_grid(interm_point)
            @warn "Intermediate inflection logic incorrect! Both intermediate points invalid."

            # Just interpolate along straight line
            route_waypts = interpolate_points_on_line(car_start_pos, car_goal_pos, route_num_waypts+1)

            for i = 1:route_num_waypts
                # Assume uniformly spread for now
                route_dict["route"][i] = [route_waypts[i+1],start_time + i*(route_duration/route_num_waypts)]
            end
        else
            # Interpolate from start to elbow and then elbow to goal
            avg_speed = route_length/route_num_waypts
            route_waypts = interpolate_points_on_line(car_start_pos, interm_point, convert(Int,round(point_dist(car_start_pos,interm_point)/avg_speed)))

            # remove last way point
            pop!(route_waypts)
            route_waypts = vcat(route_waypts, 
                interpolate_points_on_line(interm_point, car_goal_pos, convert(Int,round(point_dist(interm_point, car_goal_pos)/avg_speed))))

            for i = 1:length(route_waypts)-1
                route_dict["route"][i] = [route_waypts[i+1],start_time + i*(route_duration/route_num_waypts)]
            end
        end
    end

    perturb_car_route_times!(start_time, route_dict, params, rng)

    return route_dict
end    

"""
    generate_episode_dict_unitgrid(min_cars::Int, max_cars::Int, params::DataParameters, rng::RNG=Random.GLOBAL_RNG) where {RNG <: AbstractRNG}

Top level method that generates a full episode of valid epochs. Calls all the helper functions for this purpose.
"""
function generate_episode_dict_unitgrid(min_cars::Int, max_cars::Int, params::DataParameters, rng::RNG=Random.GLOBAL_RNG) where {RNG <: AbstractRNG}

    num_epochs = convert(Int,round((params.time_params.EPISODE_DURATION/params.time_params.EPOCH_DURATION)))
    num_total_cars = rand(rng, min_cars:max_cars)
    num_added_cars = 0

    # Adhoc numbers but not keeping as a tunable parameter
    min_car_add_epochs = 10
    avg_cars_per_epoch = params.time_params.EPOCH_DURATION*5.0

    @show num_total_cars


    # Start is always 0.0
    start_pos = SVector{2,Float64}(0.0,0.0)

    # Generate goal as a random 2D point at least a certain amount away from start
    goal_pos = rand_unif_grid_pt(rng)
    while point_dist(start_pos, goal_pos) < params.scale_params.START_GOAL_MINDIST
        goal_pos = rand_unif_grid_pt(rng)
    end

    # Initialize episode_dict
    episode_dict = Dict("num_epochs"=>num_epochs, "start_pos"=>start_pos, "goal_pos"=>goal_pos, "epochs"=>Dict())

    epoch_time = 0.0

    # Start off with 50% of the cars at the first epoch
    cars_to_add = convert(Int, round(0.5*num_total_cars))

    epoch0_dict = Dict("time"=>0.0, "car-info"=>Dict())

    for i=1:cars_to_add
        num_added_cars += 1
        epoch0_dict["car-info"][string("car-",num_added_cars)] = generate_initial_car_route(epoch_time, params, rng)
    end

    episode_dict["epochs"][0] = epoch0_dict

    # Decides how many subsequent epochs to add car routes at
    num_epochs_to_add = num_total_cars / (2.0*avg_cars_per_epoch)
    if num_epochs_to_add < min_car_add_epochs
        num_epochs_to_add = min_car_add_epochs
    elseif num_epochs_to_add > num_epochs-1
        num_epochs_to_add = num_epochs-1
    end


    epochs_to_add = sort(sample(rng,2:num_epochs,num_epochs_to_add,replace=false))

    for epoch_idx = 1:num_epochs

        curr_epoch_dict = deepcopy(episode_dict["epochs"][epoch_idx-1])
        
        # First advance existing cars with new epoch
        for car_id in collect(keys(curr_epoch_dict["car-info"]))
            advance_cars_with_epoch!(curr_epoch_dict["car-info"][car_id],epoch_time, params)
        end

        # Advance time for curr_epoch_dict
        epoch_time += params.time_params.EPOCH_DURATION
        curr_epoch_dict["time"] = epoch_time

        # Perturb the times over the rest of the route
        for (car_id,car_ep_dict) in curr_epoch_dict["car-info"]
            if car_ep_dict["route"] != nothing
                perturb_car_route_times!(epoch_time, car_ep_dict, params, rng)
            end
        end

        cars_to_add = 0

        if epoch_idx in epochs_to_add
            cars_to_add = convert(Int64,round(num_total_cars/(2.0*num_epochs_to_add)))
            # println(cars_to_add," cars added in epoch ",epoch_idx)
        end


        # Now add cars
        for i = 1:cars_to_add
            num_added_cars += 1
            curr_epoch_dict["car-info"][string("car-",num_added_cars)] = generate_initial_car_route(epoch_time, params, rng)
        end
    
        episode_dict["epochs"][epoch_idx] = curr_epoch_dict

    end

    return episode_dict,start_pos,goal_pos
end



# Script level code
#Arguments are <min-cars> <max-cars> <params-file> <file-name> <num-files>
min_cars = parse(Int,ARGS[1])
max_cars = parse(Int, ARGS[2])
params_file = ARGS[3]
filename_pref = ARGS[4]
num_files = parse(Int,ARGS[5])

# First obtain the params
params = parse_data_params(params_file)

# For reproducibility
rng = MersenneTwister(5)

for idx = 1:num_files
    println("File ",idx)
    filename = string(filename_pref,"-",idx,".json")
    ep_dict,start_pos,goal_pos = generate_episode_dict_unitgrid(min_cars, max_cars, params, rng)
    epochs_dict = ep_dict["epochs"]

    open(filename,"w") do f
        JSON.print(f,ep_dict,2)
    end

    color_map = Dict()
    p = plot_drone_and_active_cars_epoch!(epochs_dict[1], Point(start_pos[1],start_pos[2]), Point(goal_pos[1],goal_pos[2]), color_map)
    draw(PNG("test_fig.png", 25cm, 25cm), p)

end